# 14. Trapping Rain Water

https://leetcode.com/problems/trapping-rain-water/description/

You are given an array of non-negative integers `height` which represent an elevation map. Each value `height[i]` represents the height of a bar, which has a width of `1`.

Return the maximum area of water that can be trapped between the bars.

# Solution

https://www.youtube.com/watch?v=ZI2z5pq0TqA

Key insight: Water at any position depends on the **shorter** wall between the left and right sides. If the left wall is shorter, the amount of water is limited by the left side. Hence, we move the left pointer inwards, and calculate how much water can be trapped. Similarly, if the right wall is shorter, we move the right pointer inwards.

## Solution 1: Prefix + Suffix Array

```py
class Solution:
    def trap(self, height: List[int]) -> int:
        prefix_heights = [0] * len(height) # prefix_heights[i] = maximum height seen for all j < i
        suffix_heights = [0] * len(height) # suffix_heights[i] = maximum height seen for all j > i

        for i in range(1, len(height)): # Populate prefix_heights - prefix_heights[0] = 0 as there is no wall on the left
            prefix_heights[i] = max(prefix_heights[i - 1], height[i - 1])

        for i in range(len(height) - 2, -1, -1): # Populate suffix_heights - suffix_heights[-1] = 0 as there is no wall on the right
            suffix_heights[i] = max(suffix_heights[i + 1], height[i + 1])

        result = 0
        for i in range(len(height)): # At position i, the amount of water trapped is min(prefix_heights[i], suffix_heights[i]) - height[i]
            result += max(0, min(prefix_heights[i], suffix_heights[i]) - height[i]) # Make sure water always >= 0

        return result
```

For a list of $N$ `height`:
- Time complexity: $O(N)$
- Space complexity: $O(N)$

## Solution 2: Two Pointers

```py
class Solution:
    def trap(self, height: List[int]) -> int:
        left = 0
        right = len(height) - 1
        left_max = height[left] # Maximum left wall height we have seen
        right_max = height[right] # Maximum right wall height we have seen

        result = 0
        while left < right: # While pointers have not met
            if left_max < right_max: # If the left side is shorter
                left += 1 # Move left pointer inwards
                left_max = max(left_max, height[left]) # Update the maximum height on the left
                result += left_max - height[left] # Add the current water trapped at this particular position (index left)
            else: # If the right side is shorter
                right -= 1 # Move right pointer inwards
                right_max = max(right_max, height[right]) # Update the maximum height on the right
                result += right_max - height[right] # Add the current water trapped at this particular position (index right)

        return result
```

For a list of $N$ `height`:
- Time complexity: $O(N)$
- Space complexity: $O(1)$