# 19. Sliding Window Maximum

https://leetcode.com/problems/sliding-window-maximum/description/

You are given an array of integers `nums` and an integer `k`. There is a sliding window of size `k` that starts at the left edge of the array. The window slides one position to the right until it reaches the right edge of the array.

Return a list that contains the maximum element in the window at each step.

# Solution

## Solution 1: Max Heap

Key insight: We can use a max-heap to easily track the largest element of the current window. We only need to worry about what is on top of the max heap. If the top of the max heap is outside our window, we should just remove it from the heap. We can track the index of the element by inserting `(-value, index)` into our heap.

```py
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        heap = []
        for i in range(k):
            heapq.heappush(heap, (-nums[i], i))

        result = [-heap[0][0]]

        left = 1
        for right in range(k, len(nums)):
            heapq.heappush(heap, (-nums[right], right))
            while len(heap) > 0 and heap[0][1] < left:
                heapq.heappop(heap)

            left += 1
            result.append(-heap[0][0])

        return result
```

For a list of $N$ `nums`:
- Time complexity: $O(N \log N)$
- Space complexity: $O(N)$

## Solution 2: Deque

https://www.youtube.com/watch?v=DfljaUwZsOk

```py
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        result = []
        queue = deque()
        left = 0
        right = 0

        while right < len(nums):
            while len(queue) > 0 and nums[queue[-1]] < nums[right]: # While the number on the right of the window is larger than the last number in our queue
                queue.pop() # Remove the number

            queue.append(right) # Append this right number

            # Remove left value from deque if it is out of our window
            if left > queue[0]:
                queue.popleft()

            if right + 1 >= k: # If we have a full window
                result.append(nums[queue[0]]) # Update the result with our maximum
                left += 1 # Increment left pointer

            right += 1 # Increment right pointer

        return result
```

- Time complexity: $O(N)$
- Space complexity: $O(N)$