# 15. Best Time to Buy and Sell Stock

https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/

You are given an integer array `prices` where `prices[i]` is the price of NeetCoin on the `ith` day.

You may choose a single day to buy one NeetCoin and choose a different day in the future to sell it.

Return the maximum profit you can achieve. You may choose to not make any transactions, in which case the profit would be 0.

# Solution

## Solution 1: Suffix Array

Key insight: `suffix[i]` will be the maximum price after day `i`. So `suffix[i] - prices[i]` will be the profit gained from buying on day `i`, and selling after day `i`.

```py
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        suffix = [0] * len(prices)
        for i in range(len(prices) - 2, -1, -1):
            suffix[i] = max(suffix[i + 1], prices[i + 1])

        result = 0
        for i in range(len(prices)):
            result = max(result, suffix[i] - prices[i])

        return result
```

For a list of $N$ `prices`:
- Time complexity: $O(N)$
- Space complexity: $O(N)$

## Solution 2: Two Pointers

Key insight: We have `left` corresponding to our buy day, and `right` corresponding to our sell day. If `prices[left] < prices[right]`, we will make a profit, and we can increment `right` to continue exploring. If not, we have found a cheaper day to buy a stock, and this would mean we should buy on day `right` instead.

```py
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        left, right = 0, 1 # left: Buy day, right: Sell day
        max_profit = 0

        while right < len(prices): # While we have not finished processing the array
            if prices[left] < prices[right]: # If we can make a profit
                max_profit = max(max_profit, prices[right] - prices[left]) # Update our max profit
            else: # If we cannot make a profit, prices[right] <= prices[left], so we should buy on `right`, because it is cheaper
                left = right

            right += 1

        return max_profit
```

For a list of $N$ `prices`:
- Time complexity: $O(N)$
- Space complexity: $O(1)$

## Solution 3: Dynamic Programming

Key insight: We keep track of the minimum price we have seen so far - this would be the optimal day to buy. The best profit would be selling `today - min_price_seen`

```py
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        max_profit = 0 # Keep track of the maximum profit we can make
        min_buy = prices[0] # Keep track of the minimum price we have seen so far

        for sell in prices: # Assuming we are selling today
            max_profit = max(max_profit, sell - min_buy) # Update profit
            min_buy = min(min_buy, sell) # Update minimum price we have seen

        return max_profit
```