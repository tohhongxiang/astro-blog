# 18. Minimum Window Substring

https://leetcode.com/problems/minimum-window-substring/description/

Given two strings `s` and `t`, return the shortest substring of `s` such that every character in `t`, including duplicates, is present in the substring. If such a substring does not exist, return an empty string `""`.

You may assume that the correct output is always unique.

# Solution

```py
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if len(t) == 0 or len(s) == 0 or len(t) > len(s):
            return ""

        count = Counter(t) # Frequencies of characters in t
        required_matches = len(count) # Number of matches we need for a valid substring
        current_matches = 0 # Current matches we have within our sliding window
        seen = defaultdict(int) # Characters we have seen within our sliding window, and their frequencies { [character]: frequency }

        best_window = [-1, -1] # Shortest window we currently have
        best_length = float('inf') # Shortest window length we currently have

        left = 0 # Initialize left pointer at the start of s
        for right in range(len(s)): # Traverse through s
            right_character = s[right] # Look at the right character
            if right_character not in count: # If the right character is not in t, we can continue without additional processing
                continue

            seen[right_character] += 1 # Update the frequency of the right character

            if seen[right_character] == count[right_character]: # If our frequency matches, we have a new match
                current_matches += 1

            if current_matches != required_matches: # If we have not fully matched t, we continue
                continue

            # We have now fully matched t, and we now want to shrink our sliding window
            while current_matches == required_matches:
                current_length = right - left + 1 # Calculate the current length of our sliding window
                if current_length < best_length: # If our window is smaller than the previous one we have seen, update our results
                    best_length = current_length
                    best_window = [left, right]

                left_character = s[left] # Look at the left character that we are planning to remove
                if left_character in count: # If our left character is in t, we need to update the frequencies
                    seen[left_character] -= 1 # Remove the left character
                    if seen[left_character] < count[left_character]: # If our window now has less than required, we have lost a match
                        current_matches -= 1

                left += 1

        if best_window[0] < 0 or best_window[1] < 0:
            return ""
            
        return s[best_window[0]:best_window[1] + 1] # Return the final string
```

For a string `s` of length $M$ and a string `t` of length $N$:
- Time complexity: $O(M)$: Each pointer traverses through `s` at most once, moving only forwards
- Space complexity: $O(N)$, `count` and `seen` have at most $N$ keys for $N$ unique characters in `t`