# 17. Permutation In String

https://leetcode.com/problems/permutation-in-string/description/

You are given two strings `s1` and `s2`.

Return `true` if `s2` contains a permutation of `s1`, or `false` otherwise. That means if a permutation of `s1` exists as a substring of `s2`, then return `true`.

Both strings only contain lowercase letters.

# Solution

## Solution 1: Hash Map

```py
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        if len(s1) > len(s2): # If s1 is longer than s2, s2 will never have a permutation of s1
            return False

        count = Counter(s1) # Frequency map for all characters in s1
        seen = defaultdict(int) # Characters and their frequencies in s2, with a window of the length of s1
        for i in range(len(s1) - 1): # Start with a window 1 less than length of s1
            seen[s2[i]] += 1

        left = 0 # Left pointer of sliding window
        for right in range(len(s1) - 1, len(s2)):
            seen[s2[right]] += 1 # Add the right character of the sliding window to seen

            is_permutation = True # Assume we have a match
            for character in count.keys(): # Go through all unique characters in s1 and their frequencies
                if count[character] != seen[character]: # If the frequencies do not match, it is not a permutation, immediately break
                    is_permutation = False
                    break

            if is_permutation: # If all frequencies match, we have found the permutation. Return true
                return True

            # Update sliding window
            seen[s2[left]] -= 1  # Remove 1 count of the left character in the window
            left += 1 # Increment left pointer

        return False # We did not find a permutation
```

For `s1` with length $M$, and `s2` with length $N$:
- Time complexity: $O(MN)$, to traverse through `s2` and a nested loop to check all characters in `s1`
- Space complexity: $O(1)$, because we can have at most 26 characters (Technically it is $O(M)$)

## Solution 2: Sliding Window

Key insight: We do not have to always recheck the entire frequency array/dictionary. We can just check the letter we add/remove from the sliding window
1. We track the frequencies of the characters appearing using 2 frequency arrays: One for `s1` (`s1_counts`), and one for the current window in `s2` (`s2_counts`). Each of these arrays are of length 26, from `"a"` to `"z"`.
2. If the whole array matches (`matches == 26`), we have a valid permutation. We can check that the whole array matches using a counter `matches`. If `matches == 26`, then the whole array matches.
3. When we add the right character `s2[right]`, we can just check how the frequencies changed between `s1_count` and `s2_count` for that specific character:
   1. We calculate the index in the array corresponding to this character (`index = ord(s2[right]) - ord("a")`)
   2. If, after adding the character, the frequencies are equal (`s1_count[index] == s2_count[index]`), we have a new match, and can increment `matches += 1`
   3. If, after adding the character, `s1_count[index] == s2_count[index] - 1`, then previously we had a match, and now we do not have a match, and we decrement `matches -= 1`
   4. Otherwise, we never had a match in the first place, we do not update `matches`
4. Similarly, for the left pointer. When we remove the left character `s2[left]`, we can just check for that specific character:
   1. We calculate the index in the array corresponding to the left character (`index = ord(s2[left]) - ord("a")`)
   2. If, after removing the character, the frequencies are equal (`s1_count[index] == s2_count[index]`), we have a new match, and we increment `matches += 1`
   3. If, after removing the character, `s1_count[index] == s2_count[index] + 1`, then previously we had a match, and now we do not have a match, and we decrement `matches -= 1`
   4. Otherwise, we never had a match in the first place, and we do not update `matches`

```py
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        if len(s1) == 0:
            return True

        NUMBER_OF_ALPHABETS = 26
        if len(s1) > len(s2): # If s1 is longer than s2, we definitely will not have a permutation of s1 within s2
            return False

        s1_count, s2_count = [0] * NUMBER_OF_ALPHABETS, [0] * NUMBER_OF_ALPHABETS # Keep track of the counts
        for i in range(len(s1)): # Go through s1, and the first window of s2 of size len(s1), and update the frequencies
            s1_count[ord(s1[i]) - ord("a")] += 1
            s2_count[ord(s2[i]) - ord("a")] += 1

        matches = sum([s1_count[i] == s2_count[i] for i in range(NUMBER_OF_ALPHABETS)]) # Count number of matches we currently have
        left = 0
        for right in range(len(s1), len(s2)): # We only need to start from len(s1), and go until the end of s2
            if matches == NUMBER_OF_ALPHABETS: # We have a full match, a valid permutation exists
                return True

            right_index = ord(s2[right]) - ord("a") # Calculate the index of the right character in our frequency array
            s2_count[right_index] += 1 # Update the frequency after adding the right character
            if s1_count[right_index] == s2_count[right_index]: # If we have a new match, increment matches
                matches += 1
            elif s1_count[right_index] == s2_count[right_index] - 1: # If we previously had a match, and now we do not, decrement matches
                matches -= 1

            left_index = ord(s2[left]) - ord("a") # Calculate the index of the left character in our frequency array
            s2_count[left_index] -= 1 # Update the frequency after removing the left character
            if s1_count[left_index] == s2_count[left_index]: # If we have a new match, increment matches
                matches += 1
            elif s1_count[left_index] == s2_count[left_index] + 1: # If we previously had a match, and now we do not, decrement matches
                matches -= 1

            left += 1 # Update left pointer

        return matches == NUMBER_OF_ALPHABETS
```

For `s1` with length $M$, and `s2` with length $N$:
- Time complexity: $O(M + N) \approx O(N)$, to traverse through `s2`
- Space complexity: $O(1)$, because we can have at most 26 characters
