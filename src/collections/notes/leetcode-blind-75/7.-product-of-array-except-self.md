# 7. Products of Array Except Self

https://leetcode.com/problems/product-of-array-except-self/description/

Given an integer array `nums`, return an array output where `output[i]` is the product of all the elements of `nums` except `nums[i]`.

Each product is guaranteed to fit in a 32-bit integer.

Follow-up: Could you solve it in $O(n)$ time without using the division operation?

# Solution

## Solution 1: Division

Key insight: If we know the product of all **non-zero** numbers, we can compute the answer for each position using division. So, we check how many zeroes the array has:
1. If there are 2 or more zeroes, then every product will include at least one zero, thus the entire result is all zeroes.
2. If there is exactly one zero, then the only position containing that zero will be the product of all non-zero numbers. All other positions are zero.
3. If there are no zeroes, we can compute `result[i] = total_product // nums[i]`

```py
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        product = 1 # product of non-zero numbers
        zeroes = 0 # count of zeroes in nums

        for i in range(len(nums)):
            if nums[i] == 0:
                zeroes += 1
            else:
                product *= nums[i]

        if zeroes > 1: # 2 or more zeroes: everything is zero
            return [0] * len(nums)

        if zeroes == 1: # exactly 1 zero: Every other position is zero, the zero will have the non-zero product
            return [0 if num != 0 else product for num in nums]

        # no zeroes: Divide
        return [product // num for num in nums]
```

For a list of $N$ numbers:
- Time complexity: $O(N)$
- Space complexity: $O(1)$ extra space, $O(N)$ for the output

## Solution 2: Prefix + Suffix Product

Key insight: For each index `i`, we compute the product of all elements before it, and all elements after it. We keep this precomputation in 2 separate arrays: `prefixProduct` (`prefixProduct[i]` is the product of all elements before `i`) and `suffixProduct` (`suffixProduct[i]` is the product of all elements after `i`).

Then the final answer for each index is `result[i] = prefixProduct[i] * suffixProduct[i]`

```py
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)

        prefixProduct = [0] * n
        prefixProduct[0] = 1 # Nothing to the left of index 0
        for i in range(1, n): # Start from index 1 (second element) to the end
            prefixProduct[i] = prefixProduct[i - 1] * nums[i - 1]

        suffixProduct = [0] * n
        suffixProduct[n - 1] = 1 # Nothing to the right of index 0
        for i in range(n - 2, -1, -1): # Start from index n - 2 (second last element) to the start
            suffixProduct[i] = suffixProduct[i + 1] * nums[i + 1]

        result = [0] * n
        for i in range(n):
            result[i] = prefixProduct[i] * suffixProduct[i]

        return result
```

For a list of $N$ `nums`:
- Time complexity: $O(N)$
- Space complexity: $O(N)$

## Solution 3: Optimal Prefix + Suffix Product

Instead of using 2 arrays, we can use a single `result` and do 2 passes:
1. In the first pass, we fill `result[i]` with the product of all elements to the left of `i` (prefix product).
2. In the second pass, we fill `result[i]` with the product of all elements to the right of `i` (suffix product).

This prevents the need for a `prefixProduct` and `suffixProduct` array.

```py
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        result = [1] * len(nums)
        prefixProduct = 1

        for i in range(1, len(nums)):
            prefixProduct *= nums[i - 1]
            result[i] *= prefixProduct

        suffixProduct = 1
        for i in range(len(nums) - 2, -1, -1):
            suffixProduct *= nums[i + 1]
            result[i] *= suffixProduct

        return result
```