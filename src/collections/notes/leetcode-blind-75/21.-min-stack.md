# 21. Min Stack

https://leetcode.com/problems/min-stack/description/

Design a stack class that supports the `push`, `pop`, `top`, and `getMin` operations.

- `MinStack()` initializes the stack object.
- `void push(int val)` pushes the element val onto the stack.
- `void pop()` removes the element on the top of the stack.
- `int top()` gets the top element of the stack.
- `int getMin()` retrieves the minimum element in the stack.

Each function should run in $O(1)$ time.

# Solution

## Solution 1: Two Stacks

Key insight: We have one stack to keep track of numbers appended onto the stack, and another stack `minimum`, where `minimum[i]` is the minimum element up to `i`

```py
class MinStack:
    def __init__(self):
        self.numbers = []
        self.minimum = []
        
    def push(self, val: int) -> None:
        self.numbers.append(val)
        if len(self.minimum) == 0:
            self.minimum.append(val)
        else:
            self.minimum.append(min(self.minimum[-1], val))

    def pop(self) -> None:
        if len(self.numbers) > 0:
            self.numbers.pop()
        
        if len(self.minimum) > 0:
            self.minimum.pop()
        

    def top(self) -> int:
        return self.numbers[-1]

    def getMin(self) -> int:
        return self.minimum[-1]
```
- Time complexity: $O(1)$ per operation
- Space complexity: $O(N)$

## Solution 2: One Stack

Key insight: Store encoded values instead of actual numbers. We record the difference between the pushed value and the current minimum
- When a new minimum is pushed, we store a negative encoded value to signal that the minimum has changed.
- When we pop such a value, we can decode it to restore the previous minimum

```py
class MinStack:
    def __init__(self):
        self.numbers = []
        self.minimum = float('inf')
        
    def push(self, val: int) -> None:
        if len(self.numbers) == 0:
            self.numbers.append(0)
            self.minimum = val
        else:
            self.numbers.append(val - self.minimum) # When val is the new minimum, this value is negative
            self.minimum = min(val, self.minimum)

    def pop(self) -> None:
        current = self.numbers.pop()
        if current < 0: # If we popped a negative number, we popped the current minimum, and must restore the previous minimum
            self.minimum = self.minimum - current
        
    def top(self) -> int:
        if self.numbers[-1] > 0:
            return self.numbers[-1] + self.minimum # If the top is positive, it is not the minimum, and must decode the value
        else:
            return self.minimum

    def getMin(self) -> int:
        return self.minimum
```

- Time complexity: $O(1)$ per operation
- Space complexity: $O(N)$